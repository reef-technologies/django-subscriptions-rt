# Generated by Django 4.0.3 on 2023-03-21 10:14
from collections import defaultdict

import djmoney.models.fields
from django.db import migrations, models


def remove_duplicates_on_transaction(model):
    """
    The main idea is:
    - fetch all objects;
    - group them by provider and transaction id combo;
    - check all subscriptions and how many models they have assigned to them;
    - leave a single subscription with all the models attached to it, purge everything else.

    Assumptions:
    - single transaction id / codename pair is unique and assigned to a single user (we're not checking it);
    - single transaction id / codename pair belongs to a single plan, just multiple entries.
    """
    from subscriptions.providers.apple_in_app import AppleInAppProvider

    all_entries = model.objects.prefetch_related('subscription').all()

    transaction_id_to_entries = defaultdict(list)
    for entry in all_entries:
        if entry.provider_codename != AppleInAppProvider.codename:
            continue

        transaction_id_to_entries[entry.provider_transaction_id].append(entry)

    # Gather problematic entries.
    subscription_to_entries = defaultdict(list)
    transaction_id_to_subscription_uid = defaultdict(set)

    for transaction_id, transaction_id_entries in transaction_id_to_entries.items():
        # Map all subscriptions to all entries assigned to them.
        for entry in transaction_id_entries:
            subscription_to_entries[entry.subscription.uid].append(entry)

        # Single entry â€“ no issue.
        if len(transaction_id_entries) == 1:
            continue

        for entry in transaction_id_entries:
            transaction_id_to_subscription_uid[transaction_id].add(entry.subscription.uid)

    for transaction_id, subscription_uids in transaction_id_to_subscription_uid.items():
        # HERE ARE ALL SUBSCRIPTIONS FOR THE SAME TRANSACTION ID

        # Sort subscriptions by amount of children.
        subscription_uids = sorted(
            subscription_uids,
            key=lambda subscription_uid: len(subscription_to_entries[subscription_uid]),
            reverse=True,
        )

        # Pick first subscription, purge the rest.
        stay_subscription_uid, *delete_subscription_uids = subscription_uids
        for subscription_uid in delete_subscription_uids:

            children = subscription_to_entries[subscription_uid]
            subscription_obj = children[0].subscription
            for child in children:
                child.delete()

            assert subscription_obj is not None
            subscription_obj.delete()

        # pick first entry with this transaction id, purge the rest
        same_entries = [
            entry for entry in subscription_to_entries[stay_subscription_uid]
            if entry.provider_transaction_id == transaction_id
        ]
        for entry in same_entries[1:]:
            entry.delete()


def remove_subscription_duplicates(apps, scheme_editor):  # noqa (unused scheme_editor)
    models_inheriting_from_abstract_transaction = ['SubscriptionPayment', 'SubscriptionPaymentRefund']

    for model_name in models_inheriting_from_abstract_transaction:
        model = apps.get_model('subscriptions', model_name)
        remove_duplicates_on_transaction(model)


def remove_null_transaction_ids(apps, scheme_editor):  # noqa (unused scheme_editor)
    models_inheriting_from_abstract_transaction = ['SubscriptionPayment', 'SubscriptionPaymentRefund']

    for model_name in models_inheriting_from_abstract_transaction:
        model = apps.get_model('subscriptions', model_name)
        model.objects.filter(provider_transaction_id=None).all().delete()


def no_op(apps, scheme_editor):  # noqa (unused parameters)
    # Left empty intentionally. Required for testing purposes.
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('subscriptions', '0031_alter_plan_tier'),
    ]

    operations = [
        migrations.RunPython(remove_subscription_duplicates, no_op),
    ]
